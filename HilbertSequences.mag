// Parameters for defining an [n, k]_{q^m/q} linear code
q := ;
m := ;
n := ;
k := ;
pow := q + 1;
F<alpha> := GF(q^m);  // Define the finite field F of order q^m


/* Function: StarProduct
   Inputs:
     - x: a vector in F^n (ModTupFldElt)
     - y: a vector in F^n (ModTupFldElt)
   Output: A vector in F^n (ModTupFldElt) that is the component-wise product of x and y.
*/
StarProduct := function(x, y)
    X := Eltseq(x);
    Y := Eltseq(y);
    for i in [1..#X] do
        X[i] := X[i] * Y[i];
    end for;
    return VectorSpace(F, #X)!X;
end function;

/* Function: SchurProduct
   Inputs:
     - C: a linear code in F^n (LinearCode)
     - D: a linear code in F^n (LinearCode)
   Output: A linear code in F^n (LinearCode) representing the Schur product of C and D.
*/
SchurProduct := function(C, D)
    BC := Basis(C);  
    BD := Basis(D);
    G := {};    // Set to store generators of C*D
    for i in [1..#BC] do
        for j in [1..#BD] do
            G := G join {StarProduct(BC[i], BD[j])};  // Add product to generator set
        end for;
    end for;
    return LinearCode<Field(C), Length(C) | G>;  // Return new code generated by G
end function;

/* Function: SchurPower
   Inputs:
     - C: a linear code in F^n (LinearCode)
     - e: a positive integer representing the Schur power exponent (RngIntElt)
   Output: The e-th Schur power of the code C (LinearCode).
*/
SchurPower := function(C, e)
    C1 := C;  // Initialize C1 as C
    for n in [1..e-1] do
        C1 := SchurProduct(C, C1);  // Compute Schur product iteratively
    end for;
    return C1;
end function;

/* Function: CM_Regularity
   Inputs:
     - C: a linear code in F^n (LinearCode)
   Output:
    The Castelnuovo-Mumford regularity of the dimension sequence of C. (RngIntElt)
    This function also prints the dimensions of successive Schur powers until stability.
*/
CM_Regularity := function(C)
    C1 := C;
    temp := C;
    reg := 1;
    printf "[%o", Dimension(C1);  // Print initial dimension
    repeat
        temp := C1;
        reg +:= 1;
        C1 := SchurProduct(C, C1);
        printf ", %o", Dimension(C1);  // Print each dimension
    until Dimension(temp) eq Dimension(C1);  // Stop when dimension stabilizes
    printf ", %o]\n", Dimension(temp);  // Print the final dimension
    return reg - 1;  // Return C-M regularity index
end function;

/* Function: AssociatedHammingCode
   Input:
     - C: a linear code in F^n (LinearCode)
   Output: A linear code (LinearCode) associated with C.
*/
AssociatedHammingCode := function(C)
    BaseField := GF(Characteristic(Field(C)));  // Define the base field of C
    G := GeneratorMatrix(C);  // Generator matrix of C
    V := VectorSpace(BaseField, Length(C));  // Vector space over the base field
    return LinearCode(HorizontalJoin([G * Matrix(Field(C), Length(C), 1, ElementToSequence(v)) : v in V | v ne 0]));
end function;


// Gabidulin code construction: A structured rank-metric code using powers of alpha
G := LinearCode(Matrix(F, k, n, [[(alpha^i)^(q^j) : i in [0..n-1]] : j in [0..k-1]]));

// Random code construction: A random linear code in F^n
I := IdentityMatrix(F, k);  // Identity matrix for systematic form
GM := HorizontalJoin(I, Matrix(F, k, n - k, [[Random(F) : _ in [1..n - k]] : _ in [1..k]]));  // Generator matrix
R := LinearCode(GM);  // Define random linear code R

// Extended Hamming-metric codes
GH := AssociatedHammingCode(G);
RH := AssociatedHammingCode(R);

// Compute and print Castelnuovo-Mumford regularity of the extended codes
CM_Regularity(RH);
CM_Regularity(GH);
