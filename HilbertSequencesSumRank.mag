// ---------------- GLOBAL PARAMETERS ---------------- //

q := ;                    // Base field size
m := ;                    // Extension degree
k := ;                    // Code dimension

F<alpha> := GF(q^m);       // Extension field
Fq := GF(q);               // Base field

N := [];                   // Block lengths (sum-rank blocks)
t := #N;                   // Number of blocks
n := &+N;                  // Total length


// ============================================================
//                      BASIC FUNCTIONS
// ============================================================

/*
 * Schur product of two linear codes
 */
SchurProduct := function(C, D)
    BC := Basis(C);
    BD := Basis(D);
    
    G := {};
    for u in BC do
        for v in BD do
            Include(~G, u * v);
        end for;
    end for;
    return LinearCode<Field(C), Length(C) | G>;
end function;

/*
 * e-th Schur power of a code
 */
SchurPower := function(C, e)
    C1 := C;
    for i in [1..e-1] do
        C1 := SchurProduct(C, C1);
    end for;
    return C1;
end function;


/*
 * Castelnuovo–Mumford regularity
 */
CM_Regularity := function(C)
    C1 := C;
    prev := C;
    reg := 1;

    printf "[1, %o,", Dimension(C1);

    repeat
        prev := C1;
        reg +:= 1;
        C1 := SchurProduct(C, C1);
        printf " %o,", Dimension(C1);
    until Dimension(prev) eq Dimension(C1);

    printf " %o], %o\n", Dimension(prev), reg - 1;
    return reg - 1;
end function;


// ============================================================
//     ASSOCIATED HAMMING-METRIC CODE CONSTRUCTION
// ============================================================

/*
 * Associated Hamming code from a list of block generators
 *
 * Input: seq = [G1, ..., Gt], where each Gi is a list of k vectors in F^{N[i]}
 */
AssociatedHammingCode := function(seq)

    // First block
    len := #seq[1][1];
    dim := #seq[1];
    G := Matrix(F, dim, len, seq[1]);

    V := VectorSpace(Fq, len);
    GM := HorizontalJoin([
        G * Matrix(F, len, 1, ElementToSequence(v))
        : v in V | v ne 0
    ]);

    // Remaining blocks
    for i in [2..#seq] do
        len := #seq[i][1];
        dim := #seq[i];
        G := Matrix(F, dim, len, seq[i]);

        V := VectorSpace(Fq, len);
        GM := HorizontalJoin(
            GM,
            HorizontalJoin([
                G * Matrix(F, len, 1, ElementToSequence(v))
                : v in V | v ne 0
            ])
        );
    end for;

    return LinearCode(GM);
end function;


printf "q=%o, k=%o, m=%o, blocks=%o\n", q, k, m, t;

// ============================================================
//                  LINEARIZED REED–SOLOMON (LRS)
// ============================================================

print "\n==== LINEARIZED REED–SOLOMON CODES ====";

// Choose multipliers with distinct non-zero norms
repeat
    a := [];
    for i in [1..#N] do
        repeat
            elt := Random(F);
        until elt ne 0;
        Append(~a, elt);
    end for;
until #{ Norm(x, Fq) : x in a } eq t;

GLRS := [];

for i in [1..t] do

    // Choose evaluation points Fq-linearly independent
    repeat
        b := [Random(F) : _ in [1..N[i]]];
        Mb := Matrix(Fq, [Eltseq(b[j]) : j in [1..#b]]);
    until Rank(Mb) eq N[i];

    block := [b];
    for j in [1..k-1] do
        Append(~block, [(block[j][h]^q) * a[i] : h in [1..#b]]);
    end for;

    Append(~GLRS, block);
end for;

// Associated Hamming code
RH_LRS := AssociatedHammingCode(GLRS);

print "LRS code:";
rLRS := CM_Regularity(RH_LRS);


// ============================================================
//                  MULTI-BLOCK GABIDULIN CODES
// ============================================================

print "\n==== MULTI-BLOCK GABIDULIN CODES ====";

/*
 * Each block is a Gabidulin code obtained by applying
 * a random Fq-invertible linear transformation
 * to a fixed standard generator matrix.
 *
 * Assumption: all blocks have length m (i.e. N[i] = m).
 */

// Standard Gabidulin generator matrix
G0 := Matrix(F, k, m,
    [[ (alpha^i)^(q^j) : i in [0..m-1] ] : j in [0..k-1]]
);


GR_Gab := [];
for block_index in [1..t] do

    if block_index eq 1 then
        Gblock := G0;
    else
        // Sample random invertible matrix over Fq
        repeat
            A := RandomMatrix(Fq, k, k);
        until Rank(A) eq k;

        Gblock := ChangeRing(A, F) * G0;
    end if;

    // Store block as list of row vectors
    Append(~GR_Gab,
        [[Gblock[i][j] : j in [1..m]] : i in [1..k]]
    );

end for;


// Associated Hamming-metric code
RH_Gab := AssociatedHammingCode(GR_Gab);

print "Multi-block Gabidulin code:";
rGab := CM_Regularity(RH_Gab);
